# 函数

## 阶乘之和

## 函数的定义和调试

### 形式
`` 函数头 ``
`` { ``
``    函数体 ``
`` }`` 

1. 函数头：
   `` 类型名 函数名(形参表类型) ``
2. 函数体：
   (1)改程序的执行从当前函数返回其上级(调用它的函数)
   (2)释放函数的参数及变量所占用的空间
   (3)向调用函数返回一个值*(如果函数的类型不是void)*

   ``return(表达式)``**函数需要返回一个值的时候使用**

## 函数原型、声明于调用

   1. 函数原型
   1) 函数类型
   2) 函数名
   3) 函数的参数(个数、类型及其顺序)
   2. 函数的声明
   ``int f11(int age,char sex);``
   ``int ff1(int char);``
   3. 函数的调用
      (1)安排实参向形参传递数据
      (2)为参数和函数体内的变量分配内存空间
      (3)中断当前函数执行，把执行流程转向调用函数的入口，执行被调用函数
    ``函数名(实参数表列)``
    *单项传递* 当函数返回时,形参的值不传给实参，这个被称为单项传递
## 函数值的传递
   1. 值传递
   值传递是把实参的值传递给形参，而被调函数中形参的改变不会影响调用函数中实参的值，因此值的传递具有单向性
   2. 地址的传递
   地址传递时指实参的地址传递给形参，在被调用的函数中通过该地址可以访问调用函数中的实参
## 嵌套调用

## 递归调用
  1. 这个函数自己使用自己叫做递归调用
  2. 调用也是有终点的不能无终止地自己调用自己
  3. 

```
这是一个本地群发消息的装置

定义全局变量

char messagepool[100][200];    //定义群发的消息池，负责保存消息池的消息

//消息池的总数，每条消息<200个字符

  

int num = 0;   //目前消息的数量

int p = 0;     //待更新消息的数量

void push(){

    char str[200];  //发布消息的数量

    if(num>100)     //局部变量定义，申操作变量

       printf("消息已满!\n");

    else

       num++;

    printf("消息>>");

    scanf("%s",str);     //输入要发布的消息

    strncpy(messagepool[p],str,200);  //保存信息到消息池

    p = ++p % 100;

}

void display()

{

    printf("------消息池------\n");

    for(int i=0;i<num;i++)

    puts(messagepool[i]);     //将消息池里面的消息输出

    printf("————————\n");

}

int main()

{

    int cmm;     //定义局部变量定义数量

    printf("命令 = [发布信息输入1]|[显示消息输入2]|[退出输入3]\n");

    while (cmm!=3)  //控制程序在输入3的时候退出程序

    {

        printf("命令>>>");

        scanf("%d",&cmm);

        switch(cmm)

        {

            case 1:

                push();break;

            case 2:

                display();break;

        }

    }

}
```

